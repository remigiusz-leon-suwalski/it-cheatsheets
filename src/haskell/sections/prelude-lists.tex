%

\subsection{List operations}

\textbf{map} returns a list constructed by appling a function to all items in a list:
\begin{minted}{haskell}
map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs
\end{minted}

\textbf{filter} returns the list of those elements that satisfy the predicate:
\begin{minted}{haskell}
filter :: (a -> Bool) -> [a] -> [a]
filter pred []     = []
filter pred (x:xs)
  | pred x         = x : filter pred xs
  | otherwise      = filter pred xs
\end{minted}

% (++)

\textbf{head} and \textbf{last} return first and last element.
\textbf{tail}/\textbf{init} return all the elements of a list except the head/last one:
\begin{minted}{haskell}
head :: [a] -> a
head (x:_)  = x

last :: [a] -> a
last [x]    = x
last (_:xs) = last xs

tail :: [a] -> [a]
tail (_:xs) = xs

init :: [a] -> [a]
init [x]    = []
init (x:xs) = x : init xs
\end{minted}

\textbf{null} tests whether the structure is empty:
\begin{minted}{haskell}
null :: Foldable t => t a -> Bool
null = foldr (\_ _ -> False) True
\end{minted}

\textbf{length} returns the size/length of a finite structure:
\begin{minted}{haskell}
length :: Foldable t => t a -> Int 
length :: t a -> Int
length = foldl' (\c _ -> c+1) 0
\end{minted}

\textbf{reverse} returns the elements of a list in reverse order (hangs for infinite lists):
\begin{minted}{haskell}
reverse :: [a] -> [a]
reverse = foldl (flip (:)) []
\end{minted}

% and

% or

% any

% all

% concat

% concatMap

% scanl

% scanl1

% scanr

% scanr1

% iterate

% repeat

% replicate

% cycle

% take

% drop

% takeWhile

% dropWhile

% span

% break

% splitAt

% notElem

% lookup

% zip

% zip3

% zipWith

% zipWith3

% unzip

% unzip3

% lines

% words

% unlines

% unwords

%
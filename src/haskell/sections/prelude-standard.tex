%

\subsection{Standard types, classes and related functions}

\subsubsection{Basic data types}
\textbf{Bool} is a boolean type. It can have only two values: True and False.
\begin{minted}{haskell}
data Bool = False | True

(&&) :: Bool -> Bool -> Bool
True  && x = x
False && _ = False

(||) :: Bool -> Bool -> Bool
True  || _ = True
False || x = x

not :: Bool -> Bool
not True  = False
not False = True
\end{minted}

\textbf{otherwise} is defined as the value True. It helps to make guards more readable:
\begin{minted}{haskell}
f x | x < 0     = ...
    | otherwise = ...
\end{minted}

% data Maybe a

% data Either a b

% data Ordering

\textbf{Char} is a type that represents Unicode code points, which extends ISO 8859-1 (Latin-1), which extends ASCII character set.
A \textbf{String} is a list of characters:
\begin{minted}{haskell}
type String = [Char]
\end{minted}

\textbf{Tuples}:
\begin{minted}{haskell}
fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y

curry :: ((a, b) -> c) -> a -> b -> c
curry f x y = f (x, y)
-- curry fst 1 2 gives 1

uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry f p = f (fst p) (snd p)
-- uncurry (+) (1, 2) gives 3
\end{minted}

\subsubsection{Basic data types}
\textbf{Eq} class defines equality \mintinline{haskell}{==} and inequality \mintinline{haskell}{/=}.

For totally ordered datatypes, \textbf{Ord} is used which supports comparisons: \mintinline{haskell}{<}, \mintinline{haskell}{<=}, \mintinline{haskell}{>}, \mintinline{haskell}{>=}, \mintinline{haskell}{max}, \mintinline{haskell}{min}.
Note that \mintinline{haskell}{max} and \mintinline{haskell}{min} don't have to return either of their arguments but something that is equal to one of arguments in terms of \mintinline{haskell}{==}.

For sequentially ordered types, use \textbf{Enum}.
It supports (among others) methods \mintinline{haskell}{succ} (which gives the successor, like adding 1 for numeric types), \mintinline{haskell}{pred} (which gives the predecessor) and \mintinline{haskell}{toEnum}/\mintinline{haskell}{fromEnum} which convert from/to an Int.

There is also \textbf{Bounded} class that has two methods: \mintinline{haskell}{minBound}, \mintinline{haskell}{maxBound}.

\subsubsection{Numbers}
Numeric types:
\begin{itemize}
\item \textbf{Int} is a fixed-precision integer type with at least the range $-2^{29} .. 2^{29}-1$.
\item \textbf{Integer} represents the entire infinite range of integers.
\item \textbf{Float} are single-precision floating point numbers.
\item \textbf{Double} are double-precision floating point numbers.
\item \textbf{Rational} are arbitrary-precision rational numbers, represented as a ratio of two Integer values.
\item \textbf{Word} is an unsigned integral type, with the same size as Int.
\end{itemize}

%%% Numeric type classes
\textbf{Num} is a basic numeric class.
The Haskell Report defines no laws for Num.
However, (+) and (*) are customarily expected to define a ring.
\begin{minted}{haskell}
class  Num a  where
    (+), (-), (*)       :: a -> a -> a
    negate              :: a -> a
    abs                 :: a -> a
    signum              :: a -> a
    fromInteger         :: Integer -> a
    x - y               = x + negate y
    negate x            = 0 - x
\end{minted}

% class (Num a, Ord a) => Real a where

% class (Real a, Enum a) => Integral a where

% class Num a => Fractional a where

% class Fractional a => Floating a where

% class (Real a, Fractional a) => RealFrac a where

% class (RealFrac a, Floating a) => RealFloat a where

%%% Numeric functions

\subsubsection{Semigroups and Monoids}

\subsubsection{Monads and functors}

\subsubsection{Folds and traversals}

\subsubsection{Miscellaneous functions}

%
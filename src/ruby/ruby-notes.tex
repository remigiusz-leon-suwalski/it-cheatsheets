\documentclass{a5charun}
\title{Notatki z Ruby'ego 3.3.0, wersja 0.3.0}
\author{Leon Suwalski}

\setlength{\multicolsep}{6.0pt plus 1.0pt minus 1.0pt}% 50% of original values

\usepackage{xcolor}
% copied from https://www.color-hex.com/color-palette/85828
\definecolor{rubycolor}{HTML}{ffecec}
\definecolor{rubycolor2}{HTML}{990000}

% copied from https://tex.stackexchange.com/questions/132849/how-can-i-change-the-font-size-of-the-number-in-minted-environment
\BeforeBeginEnvironment{minted}{\begin{tcolorbox}[breakable,boxsep=5pt,left=0pt,right=0pt,top=0pt,bottom=0pt,boxrule=0.5pt,arc=0pt,outer arc=0pt,colback=rubycolor,colframe=rubycolor2]\small}%
\AfterEndEnvironment{minted}{\end{tcolorbox}}%

\begin{document}
\maketitle

\section{Moduły}
\input{pages/module-enumerable}

\section{Klasy}
\input{pages/class-integer}
% https://ruby-doc.org/3.3.6/Rational.html
% https://ruby-doc.org/3.3.6/Float.html#method-i-to_i
\input{pages/class-complex}

\input{pages/class-array}
\input{pages/class-string}

\newpage

If you check the list of methods on our String above you see that in Ruby we can have methods that end with a question mark ?. What’s up with that?
By convention, in Ruby, these methods return either true or false. For example, we can ask a number if it is even or odd:
These methods are called predicate methods in Ruby. Not quite sure why, maybe because of the historical math context of programming.
Bang methods end with an exlamation mark, and often modify the object they are called on. 


\section{Data types}
\input{pages/types-numbers}
\input{pages/types-strings}
\input{pages/types-booleans}
\input{pages/types-symbols}
\input{pages/types-arrays}
\input{pages/types-hashes}

\section{Require ...}
\input{pages/require-sets}
% DOES NOT REQUIRE! Math.sqrt(16)

\section{Control flow}
\input{pages/flow-conditionals}
\input{pages/flow-loops}



\section{To be done later}
\begin{minted}{ruby}
[*1..n].inject(:*)
(1..n).reduce(1,:*)


return false if num <= 1 || num % 2 == 0 || num % 3 == 0 
str1.chars.last(str2.size) == str2.chars
str.reverse!
size_compare = ending.size
str.split("").last(ending.length).join("") == ending
s.chars.each_with_index.map{ |c, i| c.upcase + c.downcase * i }.join('-')
arr.select{|x| x > 0}.reduce(0, :+)

number.even? ? "Even" : "Odd"
str.delete('aeiouAEIOU')

s.chars.find {|i| s.downcase.count(i)==1 || s.upcase.count(i)==1} || ""

numbers.split.map(&:to_i).minmax.reverse.join(' ')

(start...finish).step(2).reduce(:+)


require 'prime'
def primeFactors(n)
  n.prime_division.map {|factor, times| times == 1 ? "(#{factor})" : "(#{factor}**#{times})"}.join
end


def consecutive_fibonacci_numbers
  Enumerator.new do |yielder|
    a, b = 1, 1
    
    loop do
      yielder.yield([a, b])
      a, b = b, a + b
    end
  end
end

print vs puts, gets, gets.chomp

if, elsif, else
if vs unless
% || && ! 

5 == 5 true
5.eql?(5.0) false (diff types)
There is also .equal?

spaceship operator <=>

case (vs if)

ternary operator

3.times do ...


begin rescue end


  numbers = numbers.split.map{|word| word.to_i}
  "#{numbers.max} #{numbers.min}"
  # minmax
num.digits.map { |d| d*d } .reverse.join.to_i
arr.select{|x| x > 0}.reduce(0, :+)
l.select{|word| word.is_a? Numeric}
l.reject { |x| x.is_a? String }
l.grep(Numeric) # I knew. :D http://ruby-doc.org/core-2.3.1/Enumerable.html#method-i-grep
s[(s.size-1)/2..s.size/2] # same as length ?
s.chars.map.with_index { |s, i| (s * (i+1)).capitalize}.join("-")


\section{Built-in types}
We start with common built-in data types.

Comparison operators are \mintinline{ruby}{<}, \mintinline{ruby}{<=}, \mintinline{ruby}{<=>}, \mintinline{ruby}{==} (aliased as \mintinline{ruby}{===}), \mintinline{ruby}{>}, \mintinline{ruby}{>=}.

\mintinline{ruby}{.ceil} and \mintinline{ruby}{.floor} are functions known in math as $\lfloor x \rfloor$ and $\lceil x \rceil$ respectively.
There are \mintinline{ruby}{.round} and  \mintinline{ruby}{.truncate} as well.
Both classes support \mintinline{ruby}{.divmod} (quotient and reminder), \mintinline{ruby}{.fdiv} (float result of division) and \mintinline{ruby}{%} (modulo).
Only integers support \mintinline{ruby}{.div} and \mintinline{ruby}{remainder}.

\mintinline{ruby}{.digits} is an array of (base-10, by default) digits of an Integer.
\mintinline{ruby}{.odd?} and \mintinline{ruby}{.even?} are self explanatory.
\mintinline{ruby}{.gcd} stands for greatest common divisor, \mintinline{ruby}{.lcm} for lowest common multiple (and there is \mintinline{ruby}{.gcdlcm} too).
They are all Integer specific.

\mintinline{ruby}{&}, \mintinline{ruby}{|}, \mintinline{ruby}{^} are bitwise AND, OR, XOR;
\mintinline{ruby}{<<}, \mintinline{ruby}{>>} denote bit-shifts.

\mintinline{ruby}{.size} gives the number of bytes in the machine representation, depends on the system and makes no sense for floats.

It's possible to convert between types with \mintinline{ruby}{.to_i}, \mintinline{ruby}{.to_f}, \mintinline{ruby}{.to_s} (to string).

\subsection{Numeric types -- rationals}
To convert float, use \mintinline{ruby}{.to_r} method

Assignment operators = and shorthand +=, -= *= /=.

Variable names should always be lowercase, and multiple words that make up a variable name should be split by an underscore. This is known as snake case.

https://www.theodinproject.com/lessons/ruby-variables
http://ruby-for-beginners.rubymonstas.org/writing_classes/attribute_readers.html
https://launchschool.com/books/ruby/read/basics
\end{minted}

\end{document}




\end{minted}
\end{document}


\documentclass{a5charun}
\title{Ruby 3.3.0 notes, version 0.0.2}
\author{Leon Suwalski}

\setlength{\multicolsep}{6.0pt plus 1.0pt minus 1.0pt}% 50% of original values

\usepackage{xcolor}
% copied from https://www.color-hex.com/color-palette/85828
\definecolor{rubycolor}{HTML}{ffecec}
\definecolor{rubycolor2}{HTML}{990000}

% copied from https://tex.stackexchange.com/questions/132849/how-can-i-change-the-font-size-of-the-number-in-minted-environment
\BeforeBeginEnvironment{minted}{\begin{tcolorbox}[breakable,boxsep=5pt,left=0pt,right=0pt,top=0pt,bottom=0pt,boxrule=0.5pt,arc=0pt,outer arc=0pt,colback=rubycolor,colframe=rubycolor2]\small}%
\AfterEndEnvironment{minted}{\end{tcolorbox}}%

\begin{document}
\maketitle
\section{To be named... TODO}
\subsection{Conditionals}

\begin{multicols}{3}
\begin{minted}{ruby}
if condition
  action
elsif condition
  action
else
  action
end
\end{minted}
\columnbreak

\begin{minted}{ruby}
unless condition
  action
end
\end{minted}
\columnbreak

\begin{minted}{ruby}
case test_value
  when value
    action
  when value
    action
  else
    action
end
\end{minted}
\end{multicols}

\subsection{Loops and iterators}
Loops are blocks of code that are continually repeated until a certain condition is met.
\mintinline{ruby}{until} exists for similar reason to \mintinline{ruby}{unless}.
There is a \mintinline{ruby}{loop} loop, which is infinite and rarely used.

\mintinline{ruby}{break} and \mintinline{ruby}{next} have usual meaning.
\mintinline{ruby}{redo} goes to the start of current iteration and does it again.

\begin{multicols}{3}
\begin{minted}{ruby}
while condition
  action
end
\end{minted}
\columnbreak

\begin{minted}{ruby}
until condition
  action
end
\end{minted}
\columnbreak

\begin{minted}{ruby}
for x in xs
  action
end
\end{minted}
\end{multicols}

Instead of giving a definition of what iterator is, we present several examples:
\begin{itemize}
  \item \mintinline{ruby}{5.times { puts "Hi!" }}
  \item \mintinline{ruby}{1.upto(5) { puts "Hi!" }}
  \item \mintinline{ruby}{5.down­to(1) { puts "Hi!" }}
  \item \mintinline{ruby}{(1..5).each { puts "Hi!" }}
  \item \mintinline{ruby}{xs.each { |x| puts 1+x }}
\end{itemize}  


\section{Built-in types}
We start with common built-in data types.
\subsection{Numeric types}
There are two main types of numbers: integers and floats.
Basic arithmetical operations are denoted with \mintinline{ruby}{+}, \mintinline{ruby}{-}, \mintinline{ruby}{*}, \mintinline{ruby}{/} (division) and \mintinline{ruby}{**} (exponentiation).
Modular exponentiation of integers (but not floats!) is available as \mintinline{ruby}{.pow}, here modulus is optional.
Other common method is \mintinline{ruby}{.abs} (absolute value).

Comparison operators are \mintinline{ruby}{<}, \mintinline{ruby}{<=}, \mintinline{ruby}{<=>}, \mintinline{ruby}{==} (aliased as \mintinline{ruby}{===}), \mintinline{ruby}{>}, \mintinline{ruby}{>=}.

\mintinline{ruby}{.ceil} and \mintinline{ruby}{.floor} are functions known in math as $\lfloor x \rfloor$ and $\lceil x \rceil$ respectively.
There are \mintinline{ruby}{.round} and  \mintinline{ruby}{.truncate} as well.
Both classes support \mintinline{ruby}{.divmod} (quotient and reminder), \mintinline{ruby}{.fdiv} (float result of division) and \mintinline{ruby}{%} (modulo).
Only integers support \mintinline{ruby}{.div} and \mintinline{ruby}{remainder}.

\mintinline{ruby}{.digits} is an array of (base-10, by default) digits of an Integer.
\mintinline{ruby}{.odd?} and \mintinline{ruby}{.even?} are self explanatory.
\mintinline{ruby}{.gcd} stands for greatest common divisor, \mintinline{ruby}{.lcm} for lowest common multiple (and there is \mintinline{ruby}{.gcdlcm} too).
They are all Integer specific.

\mintinline{ruby}{&}, \mintinline{ruby}{|}, \mintinline{ruby}{^} are bitwise AND, OR, XOR;
\mintinline{ruby}{<<}, \mintinline{ruby}{>>} denote bit-shifts.

\mintinline{ruby}{.size} gives the number of bytes in the machine representation, depends on the system and makes no sense for floats.

It's possible to convert between types with \mintinline{ruby}{.to_i}, \mintinline{ruby}{.to_f}, \mintinline{ruby}{.to_s} (to string).

\subsection{Numeric types -- rationals}
To convert float, use \mintinline{ruby}{.to_r} method

\subsection{Strings}
Strings can be formed with either double or single quotes.
Single quotes disable string interpolation and escape characters.
\begin{minted}{ruby}
"Hello " + "world!"      # concatenation
"Hello " << "world!"     # shovel operator
"Hello ".concat("world!)
\end{minted}

Substrings:
\begin{minted}{ruby}
"bonjour"[0]    # "b"
"bonjour"[0..1] # "bo"
"bonjour"[0, 4] # "bonj"
"bonjour"[-1]   # "r"
\end{minted}

Interpolation:
\begin{minted}{ruby}
what = "le Monde"
puts "Bonjour, #{what}" #=> "Bonjour, le Monde"
puts 'Bonjour, #{what}' #=> "Bonjour, #{name}"
\end{minted}

String methods:
\begin{minted}{ruby}
"hello".capitalize #=> "Hello"
"hello".include?("lo")  #=> true
"hello".include?("z")   #=> false
"hello".upcase  #=> "HELLO"
"Hello".downcase  #=> "hello"
"hello".empty?  #=> false
"".empty?       #=> true
"hello".length  #=> 5
"hello".reverse  #=> "olleh"
"hello world".split  #=> ["hello", "world"]
"hello".split("")    #=> ["h", "e", "l", "l", "o"]
" hello, world   ".strip  #=> "hello, world"
\end{minted}

\subsection{Symbols}
Symbols are unique identifiers that are considered code, not data. 
\begin{minted}{ruby}
:symbol
\end{minted}
% "string" == "string"  #=> true
% "string".object_id == "string".object_id  #=> false
% :symbol.object_id == :symbol.object_id    #=> true


\subsection{Booleans}
Booleans: true and false.
Nil represents ''nothing'' and is needed because every method in Ruby always returns exactly one object.

\subsection{Arrays}
Arrays are zero-indexed, can contain all kinds of objects and have a defined order.
\begin{minted}{ruby}
words = ["one", "two", "three"]
words << "four"
puts words[10] # retrieving an element that does not exist gives nil
[1, 2] + [5, 6] # [1, 2, 5, 6]
["A", "Be"] * 2 # ["A", "Be", "A", "Be"]
& # intersection
# vvv methods vvv
.first .last .length .sort .compact .index(...) .rotate(...), .transpose
\end{minted}


\subsection{Hashes}
Like dictionaries.
\begin{minted}{ruby}
dictionary = { "one" => "eins", "two" => "zwei", "three" => "drei" }
dictionary["zero"] = "null"
puts dictionary["one"]
> { "one" => "eins" }.merge({ "two" => "zwei" })
=> { "one" => "eins", "two" => "zwei" }
> dictionary = { "one" => "eins" }
> dictionary.fetch("one")
=> "eins"
> dictionary.fetch("two")
KeyError: key not found: "two"
[] gives nil
.length
.size
{ one: "eins", two: "zwei", three: "drei" } # new syntax
{ :one => "eins", :two => "zwei", :three => "drei" } # old
\end{minted}

\begin{multicols*}{2}



TO BE DONE

\subsection{Symbols}


Assignment operators = and shorthand +=, -= *= /=.

Variable names should always be lowercase, and multiple words that make up a variable name should be split by an underscore. This is known as snake case.

print vs puts, gets, gets.chomp

if, elsif, else
if vs unless
% || && ! 

5 == 5 true
5.eql?(5) false (diff types)
There is also .equal?

spaceship operator <=>

case (vs if)

% 5_000

ternary operator

3.times do ...

while, until, for
redo

next, break

begin rescue end



\begin{minted}{ruby}
Objects - classes - methods
> "this is a string".is_a?(String)
=> true
> "this is a string".class
=> String

If you check the list of methods on our String above you see that in Ruby we can have methods that end with a question mark ?. What’s up with that?

By convention, in Ruby, these methods return either true or false. For example, we can ask a number if it is even or odd:

These methods are called predicate methods in Ruby. Not quite sure why, maybe because of the historical math context of programming.

Bang methods end with an exlamation mark, and often modify the object they are called on. 

class Person
  def initialize(name)
  end
end

You see that we add a method called initialize to the class, and this method accepts a single argument, which is called name. At the moment, this method is still empty. We’ll add some code to it in a bit.

The important bit to learn for you is: the method initialize is a special method with a special meaning in Ruby:

Whenever you call the method new on a class, as in Person.new, the class will create a new instance of itself. It will then, internally, call the method initialize on the new object. Doing so it will simply pass all the arguments that you passed to new on to the method initialize.
\end{minted}

\end{multicols*}
To be done:
\begin{minted}{ruby}
def likes(names)
  case names.size
  when 0 
    "no one likes this"
  when 1 
    "#{names[0]} likes this"
  when 2
    "#{names[0]} and #{names[1]} like this"
  when 3
    "#{names[0]}, #{names[1]} and #{names[2]} like this"
  else
    "#{names[0]}, #{names[1]} and #{names.size - 2} others like this"
  end
end

def even_or_odd(number)
  number.even? ? "Even" : "Odd"
end

("aeiouy".chars.map { |vowel| "ala ma kota".count(vowel) }).sum
inputStr.count("aeiou")
str.delete('aeiouAEIOU')
  numbers = numbers.split.map{|word| word.to_i}
  "#{numbers.max} #{numbers.min}"
  # minmax
num.digits.map { |d| d*d } .reverse.join.to_i
arr.select{|x| x > 0}.reduce(0, :+)
l.select{|word| word.is_a? Numeric}
l.reject { |x| x.is_a? String }
l.grep(Numeric) # I knew. :D http://ruby-doc.org/core-2.3.1/Enumerable.html#method-i-grep
s[(s.size-1)/2..s.size/2] # same as length ?
s.chars.map.with_index { |s, i| (s * (i+1)).capitalize}.join("-")

\end{minted}
\end{document}

https://www.theodinproject.com/lessons/ruby-variables
http://ruby-for-beginners.rubymonstas.org/writing_classes/attribute_readers.html
https://launchschool.com/books/ruby/read/basics
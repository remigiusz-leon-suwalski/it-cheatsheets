\section{Built-in Functions}
To print text, use \mintinline{python}{print()}.

Logical operations:
\begin{minted}{python}
all() # False if any element is False
any() # False if all elements are False or iterable is empty
\end{minted}

Mathematical operations:
\begin{minted}{python}
abs()    # absolute value of a number
divmod() # quotient, remainder of non-complex numbers division
min()    # smallest element
max()    # largest element
pow()    # exponentiation, with optional parameter for modulus
round()  # rounds to given precision (to integer by default)
\end{minted}

\mintinline{python}{type()} returns the type of an object.
Converting between data types:
\begin{minted}{python}
bool() # anything not listed below: True
# empty sequences, collections, zeroes, None, False: False

# hex, oct, bin require an integer
hex() # to a lowercase hexadecimal string prefixed with "0x"
oct() # to an octal string prefixed with "0o"
bin() # to a binary string prefixed with "0b"
       
# int, float require a number or string
int() # converts a number or string
float() # converts a number or string

complex() # converts a pair of numbers or string
# complex("3+4j") == complex(3,4) == (3+4j)

chr() # converts integer to character, chr(97) == 'a'
ord() # converts character to integer, ord('a') == 97

tuple()
list()
dict() # dictionary
frozenset()
range(stop)
range(start, stop, step=1)
set()
str() # string
\end{minted}

Functions for sequences/iterators:
\begin{minted}{python}
enumerate() # returns tuples containing count
            # and consecutive values of iterator
len()       # number of items, or length
reversed()  # a reverse iterator

sorted()
# with custom comparison function:
sorted(xs, key=lambda x:x[-1])
# as if each comparison were reversed:
sorted(xs, reverse=True)

sum(xs, start=0)  # sums start and the items
                  # start can't be a string
"".join(xs)       # sum alternative for strings
math.fsum(xs)     # sum alternative for floats
itertools.chain() # sum alternative for a series of iterables

zip() # aggregates (into tuples) elements from each of the iterables
\end{minted}

Functional programming:
\begin{minted}{python}
# only those elements for which function is true
filter(function, iterable)

# applies function to every element of iterable
map(function, iterable)
\end{minted}

\mintinline{python}{open()}: opens a file and then closes matching file descriptor.
\begin{minted}{python}
with open("path/to/file") as f:
	for line in f:
		# do something

with open("path/to/file", "w") as f:
	f.write("some string")
\end{minted}

Yet to be described:
\mintinline{python}{ascii()},
\mintinline{python}{aiter()},
\mintinline{python}{anext()},
\mintinline{python}{breakpoint()},
\mintinline{python}{bytearray()},
\mintinline{python}{bytes()},
\mintinline{python}{callable()},
\mintinline{python}{classmethod()},
\mintinline{python}{compile()},
\mintinline{python}{delattr()},
\mintinline{python}{dir()},
\mintinline{python}{eval()},
\mintinline{python}{exec()},
\mintinline{python}{format()},
\mintinline{python}{getattr()},
\mintinline{python}{globals()},
\mintinline{python}{hasattr()},
\mintinline{python}{hash()},
\mintinline{python}{help()},
\mintinline{python}{id()},
\mintinline{python}{input()},
\mintinline{python}{isinstance()},
\mintinline{python}{issubclass()},
\mintinline{python}{iter()},
\mintinline{python}{locals()},
\mintinline{python}{memoryview()},
\mintinline{python}{next()},
\mintinline{python}{object()},
\mintinline{python}{property()},
\mintinline{python}{repr()},
\mintinline{python}{setattr()},
\mintinline{python}{slice()},
\mintinline{python}{staticmethod()},
\mintinline{python}{super()},
\mintinline{python}{vars()}.

%
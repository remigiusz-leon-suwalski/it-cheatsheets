\section{Built-in Functions}
To print text, use \mintinline{python}{print()}.

Logical operations:
\begin{minted}{python}
all() # False if any element is False
any() # False if all elements are False or empty iterable
\end{minted}

Mathematical operations:
\begin{minted}{python}
abs()    # absolute value of a number
divmod() # quotient, remainder; requires non-complex args
min()    # smallest element
max()    # largest element
pow()    # exponentiation, with optional modulus
round()  # rounds to given precision (default: to integer)
\end{minted}

\mintinline{python}{type()} returns the type of an object.
Converting between data types:
\begin{minted}{python}
bool() # anything not listed below: True
# empty sequences, collections, zeroes, None, False: False

# hex, oct, bin convert an integer to lowercase strings:
hex() # prefixed with "0x" (base 16)
oct() # prefixed with "0o" (base 8)
bin() # prefixed with "0b" (base 2)

int() # converts to an integer
float() # converts to a floating number
# int, float require a number or a string
# int(1+0j) throws a TypeError.
complex() # converts a pair of numbers or strings
# complex("3+4j") == complex(3, 4) == 3+4j
# 3+j throws a NameError: 'j' is not defined.

chr() # converts integer to character, chr(97) == 'a'
ord() # converts character to integer, ord('a') == 97

# converting 
str() # string
list()
tuple()
dict() # dictionary
set()
frozenset()
range(stop)
range(start, stop, step=1)
\end{minted}

Functions for sequences/iterators:
\begin{minted}{python}
enumerate() # returns tuples containing count
            # and consecutive values of iterator
len()       # number of items, or length
reversed()  # a reverse iterator

sorted()
sorted(xs, key=lambda x:x[-1])
sorted(xs, reverse=True)

sum(xs, start=0)  # start can't be a string
"".join(xs)       # alternative for strings
math.fsum(xs)     # alternative for floats
itertools.chain() # alternative for a series of iterables

zip() # merges iterables element-wise
\end{minted}

Functional programming:
\begin{minted}{python}
# only those elements for which function is true
filter(function, iterable)

# applies function to every element of iterable
map(function, iterable)
\end{minted}

\mintinline{python}{open()}: opens a file and then closes matching file descriptor.
\begin{minted}{python}
with open("path/to/file", encoding="utf8") as f:
    for line in f:
        # do something

with open("path/to/file", "w") as f:
    f.write("some string")
\end{minted}

Yet to be described:
\mintinline{python}{ascii()},
\mintinline{python}{aiter()},
\mintinline{python}{anext()},
\mintinline{python}{breakpoint()},
\mintinline{python}{bytearray()},
\mintinline{python}{bytes()},
\mintinline{python}{callable()},
\mintinline{python}{classmethod()},
\mintinline{python}{compile()},
\mintinline{python}{delattr()},
\mintinline{python}{dir()},
\mintinline{python}{eval()},
\mintinline{python}{exec()},
\mintinline{python}{format()},
\mintinline{python}{getattr()},
\mintinline{python}{globals()},
\mintinline{python}{hasattr()},
\mintinline{python}{hash()},
\mintinline{python}{help()},
\mintinline{python}{id()},
\mintinline{python}{input()},
\mintinline{python}{isinstance()},
\mintinline{python}{issubclass()},
\mintinline{python}{iter()},
\mintinline{python}{locals()},
\mintinline{python}{memoryview()},
\mintinline{python}{next()},
\mintinline{python}{object()},
\mintinline{python}{property()},
\mintinline{python}{repr()},
\mintinline{python}{setattr()},
\mintinline{python}{slice()},
\mintinline{python}{staticmethod()},
\mintinline{python}{super()},
\mintinline{python}{vars()}.

%